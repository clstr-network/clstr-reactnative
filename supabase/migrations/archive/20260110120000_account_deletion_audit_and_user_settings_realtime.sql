-- Account deletion audit log + ensure user_settings is realtime-enabled + auto-create settings rows

-- 1) Audit table (RLS-protected insert for self-service deletions)
CREATE TABLE IF NOT EXISTS public.account_deletion_audit (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid NOT NULL,
  email text,
  source text NOT NULL DEFAULT 'settings',
  created_at timestamptz NOT NULL DEFAULT now()
);

ALTER TABLE public.account_deletion_audit ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can insert own account deletion audit" ON public.account_deletion_audit;
CREATE POLICY "Users can insert own account deletion audit"
  ON public.account_deletion_audit
  FOR INSERT
  TO authenticated
  WITH CHECK (user_id = auth.uid());

-- 2) Ensure new profiles get a settings row (prevents Settings reset/failure on reload)
CREATE OR REPLACE FUNCTION public.create_user_settings_on_profile_insert()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.user_settings (user_id)
  VALUES (NEW.id)
  ON CONFLICT (user_id) DO NOTHING;

  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS create_user_settings_on_profile_insert ON public.profiles;
CREATE TRIGGER create_user_settings_on_profile_insert
  AFTER INSERT ON public.profiles
  FOR EACH ROW
  EXECUTE FUNCTION public.create_user_settings_on_profile_insert();

-- 3) Realtime publication for user_settings (required for postgres_changes subscriptions)
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_publication WHERE pubname = 'supabase_realtime') THEN
    BEGIN
      ALTER PUBLICATION supabase_realtime ADD TABLE public.user_settings;
    EXCEPTION
      WHEN duplicate_object THEN
        NULL;
    END;
  END IF;
END;
$$;
